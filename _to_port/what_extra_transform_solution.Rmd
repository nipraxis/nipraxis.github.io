---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.5
---

$\newcommand{L}[1]{\| #1 \|}\newcommand{VL}[1]{\L{ \vec{#1} }}\newcommand{R}[1]{\operatorname{Re}\,(#1)}\newcommand{I}[1]{\operatorname{Im}\, (#1)}$

<!-- vim: ft=rst -->
## Extra transform exercise

```{python}
#: standard imports
import numpy as np
import numpy.linalg as npl
import matplotlib.pyplot as plt
# print arrays to 4 decimal places
np.set_printoptions(precision=4, suppress=True)
import nibabel as nib
```

```{python}
#: gray colormap and nearest neighbor interpolation by default
plt.rcParams['image.cmap'] = 'gray'
plt.rcParams['image.interpolation'] = 'nearest'
```

## What transforms did I add?

I took this image

* `ds114_sub009_highres.nii`

and I made a new copy, in `img, hdr` format (see
The image header and affine):

* `ds114_sub009_highres_moved.img`;
  `ds114_sub009_highres_moved.hdr`.

I then modified the affine in `ds114_sub009_highres_moved.hdr` to add an
extra rotation and translation.

<!-- The script to do the transform is make_ds114_anat.py -->
What extra translation and rotation did I add?

Hint: remember the rotation formulae from Rotations and rotation matrices:

$$
\begin{alignat}{1}
R_x(\theta) &= \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos \theta &  -\sin \theta \\[3pt]
0 & \sin \theta  &  \cos \theta \\[3pt]
\end{bmatrix} \\[6pt]
R_y(\theta) &= \begin{bmatrix}
\cos \theta & 0 & \sin \theta \\[3pt]
0 & 1 & 0 \\[3pt]
-\sin \theta & 0 & \cos \theta \\
\end{bmatrix} \\[6pt]
R_z(\theta) &= \begin{bmatrix}
\cos \theta &  -\sin \theta & 0 \\[3pt]
\sin \theta & \cos \theta & 0\\[3pt]
0 & 0 & 1\\
\end{bmatrix}
\end{alignat}
$$

You might also want to compare against results from the
`rotations.py` module:

```{python}
#: functions to make rotation matrices
from rotations import x_rotmat, y_rotmat, z_rotmat
```

Final hint:

* inverse sine, cosine are `np.arcsin, np.arccos`.

```{python}
#: Get the original image affine
import nibabel as nib
orig_img = nib.load('ds114_sub009_highres.nii')
print(orig_img.affine)
```

```{python}
#: Get the new image affine
moved_img = nib.load('ds114_sub009_highres_moved.img')
moved_img.affine
```

```{python}
#- Work out what transform has been added in the new affine
extra = moved_img.affine.dot(npl.inv(orig_img.affine))
extra
```

```{python}
#- What rotation and translation has been applied?
z_angle = np.arccos(extra[0, 0])
translation = extra[:3, 3]
z_angle, translation
```

<!-- vim:ft=rst -->
<!-- Course -->
<!-- BIC -->
<!-- Python distributions -->
<!-- Version control -->
<!-- Editors -->
<!-- Python and common libraries -->
<!-- IPython -->
<!-- Virtualenv and helpers -->
<!-- Pypi and packaging -->
<!-- Mac development -->
<!-- Windows development -->
<!-- Nipy and friends -->
<!-- FMRI datasets -->
<!-- Languages -->
<!-- Imaging software -->
<!-- Installation -->
<!-- Tutorials -->
<!-- MB tutorials -->
<!-- Ideas -->
<!-- Psych-214 -->
<!-- People -->
<!-- Licenses -->
<!-- Neuroimaging stuff -->
<!-- OpenFMRI projects -->
<!-- Unix -->
<!-- Substitutions -->
