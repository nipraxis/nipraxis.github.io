---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.5
---

$\newcommand{L}[1]{\| #1 \|}\newcommand{VL}[1]{\L{ \vec{#1} }}\newcommand{R}[1]{\operatorname{Re}\,(#1)}\newcommand{I}[1]{\operatorname{Im}\, (#1)}$

<!-- vim: ft=rst -->
## Applying deformations exercise

Requirements:

* Removing length 1 axes with numpy.squeeze;

* numpy.tranpose for swapping axes;

* Resampling with scipy.ndimage;

* The nibabel.affines module;

* General resampling between images with scipy.ndimage.map_coordinates.

```{python}
#: standard imports
import numpy as np
import matplotlib.pyplot as plt
# print arrays to 4 decimal places
np.set_printoptions(precision=4, suppress=True)
import numpy.linalg as npl
import nibabel as nib
```

```{python}
#: gray colormap and nearest neighbor interpolation by default
plt.rcParams['image.cmap'] = 'gray'
plt.rcParams['image.interpolation'] = 'nearest'
```

## Applying a deformation field

We should have already calculated the deformation field for the image
`ds107_sub012_highres.nii`.

We did this using the SPM12 `Normalise: Estimate` option from the GUI.

This should have left an image called `y_ds107_sub012_highres.nii` in
your working directory.

If not:

* Ask for help;

* If you get stuck, you can download the image from
  `y_ds107_sub012_highres.nii`.

We make an image object for this deformations image by loading with nibabel.

```{python}
#: load y_ds107_sub012_highres.nii with nibabel
# get the image array data
deformations_img = nib.load('y_ds107_sub012_highres.nii')
deformations_data = deformations_img.get_data()
deformations_data.shape
```

We are going to work out how to apply this *deformations* image to reslice our
original image `ds107_sub012_highres.nii`.

Oddly - this is a 5 dimensional image, where the 4th dimension is length 1.

The length-1 4th dimension is an artefact of the [NIfTI image format](http://nifti.nimh.nih.gov/nifti-1) – so let’s get rid of this dimension with np.squeeze:

```{python}
#: remove length-1 4th dimension from deformation data
deformations_data = np.squeeze(deformations_data)
deformations_data.shape
```

The data is now a 4-dimensional image, containing 3 volumes. These volumes
are:

* x coordinates;

* y coordinates;

* z coordinates

respectively.

Put another way, the vector `deformations_data[i, j, k, :]` gives the (x, y,
z) coordinates for the voxel `[i, j, k]`. More on this later.

If you were looking carefully at the SPM interface, SPM has calculated the
distortions necessary to go from a template of *tissue probability maps*
(called `TPM.nii`) to the `ds107_sub012_highres.nii` image.

We can get the original 3D shape and affine of `TPM.nii` because SPM stored
them in `y_ds107_sub012_highres.nii`:

```{python}
#: get original TPM.nii 3D shape and affine
tpm_shape = deformations_data.shape[:3]
tpm_affine = deformations_img.affine
tpm_affine
```

First we look at the images before the normalization has been applied.

To do that, we will make a new copy of the MNI template, with the same shape
as the TPM image.

The MNI template image we will use is
`mni_icbm152_t1_tal_nlin_asym_09a.nii`.

```{python}
#: load the template image we will resample from
template_img = nib.load('mni_icbm152_t1_tal_nlin_asym_09a.nii')
template_data = template_img.get_data()
template_data.shape
```

Now we need the mapping from voxels in `TPM.nii` to voxels in
`mni_icbm152_t1_tal_nlin_asym_09a.nii`.

We can break this down into two transforms:

* from voxels in `TPM.nii` to (x, y, z) mm;

* from (x, y, z) mm to voxels in `mni_icbm152_t1_tal_nlin_asym_09a.nii`.

We have these transforms already. The full transform is:

```{python}
#: voxels in TPM.nii to voxels in mni_icbm152_t1_tal_nlin_asym_09a.nii
# Matrix multiplication is right to left
vox2vox = npl.inv(template_img.affine).dot(tpm_affine)
vox2vox
```

We break this down into the 3 x 3 `mat` and length 3 `vec` components:

```{python}
#: to mat and vec
mat, vec = nib.affines.to_matvec(vox2vox)
mat
vec
```

Then we resample from the MNI template, into the voxel grid of the
`TPM.nii`:

```{python}
#: resample MNI template onto TPM grid
from scipy.ndimage import affine_transform
template_into_tpm = affine_transform(template_data, mat, vec,
                                     output_shape=tpm_shape)
template_into_tpm.shape
```

Here is the new version of the template image:

```{python}
#: plot the template image resampled onto the TPM grid
plt.imshow(template_into_tpm[:, :, 60])
```

Now, what to do with with the SPM distortion field in `deformations_data`?

By checking in the SPM source code , it is possible to
work out that `deformations_data` contains, for every voxel in TPM, the
corresponding mm coordinate in the *mm space* of the subject image.

That is, `deformations_data[i, j, k]` is a length 3 vector `[x, y, z]`
where `[x, y, z]` are the mm coordinates of voxel `[i, j, k]` when mapped
into millimeters for the subject image.

Here is the subject data, and the image, which contains the affine:

```{python}
#: load the subject data that we will resample from
subject_img = nib.load('ds107_sub012_highres.nii')
subject_data = subject_img.get_data()
subject_data.shape
```

With this information, and with the `scipy.ndimage.map_coordinates`
function, you should be able to:

* get the mapping from voxels in TPM to voxels in the subject image and;

* resample the subject image into the grid of the TPM image using this
  mapping.

Hint: remember that map_coordinates expects the
3-length coordinate dimension to be first, but `deformations_data` – at
the moment – has the 3-length coordinate dimension last.

<!-- rewrite using reshape, mat vec -->

```{python}
#- * get mapping from voxels in TPM to voxels in the subject image;
#- * resample the subject image into the grid of the TPM image using
#-   this mapping.
from scipy.ndimage import map_coordinates
vox2vox_mapping = nib.affines.apply_affine(npl.inv(subject_img.affine), deformations_data)
for_map_coords = vox2vox_mapping.transpose(3, 0, 1, 2)
subject_into_tpm = map_coordinates(subject_data, for_map_coords)
subject_into_tpm.shape
```

Show an example slice from the template resampled into the TPM voxel grid, and the subject
resampled into the TPM voxel grid:

```{python}
#- show an example slice from the resampled template and resampled
#- subject
fig, axes = plt.subplots(1, 2, figsize=(10, 5))
axes[0].imshow(template_into_tpm[:, :, 60])
axes[1].imshow(subject_into_tpm[:, :, 60])
```

<!-- vim:ft=rst -->
<!-- Course -->
<!-- BIC -->
<!-- Python distributions -->
<!-- Version control -->
<!-- Editors -->
<!-- Python and common libraries -->
<!-- IPython -->
<!-- Virtualenv and helpers -->
<!-- Pypi and packaging -->
<!-- Mac development -->
<!-- Windows development -->
<!-- Nipy and friends -->
<!-- FMRI datasets -->
<!-- Languages -->
<!-- Imaging software -->
<!-- Installation -->
<!-- Tutorials -->
<!-- MB tutorials -->
<!-- Ideas -->
<!-- Psych-214 -->
<!-- People -->
<!-- Licenses -->
<!-- Neuroimaging stuff -->
<!-- OpenFMRI projects -->
<!-- Unix -->
<!-- Substitutions -->
